<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Xtra Blog</title>
	<link rel="stylesheet" href="fontawesome/css/all.min.css"> <!-- https://fontawesome.com/ -->
	<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet"> <!-- https://fonts.google.com/ -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/templatemo-xtra-blog.css" rel="stylesheet">
<!--
    
TemplateMo 553 Xtra Blog

https://templatemo.com/tm-553-xtra-blog

-->
</head>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<style>
    table {
        width: 100%;
        border-collapse: collapse;
        text-align: center;
    }
    th, td {
        border: 1px solid black;
        padding: 8px;
    }
    .highlight {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    .boxed {
        border: 2px solid black;
        padding: 5px;
    }
</style>
<body>
    <div id="sidebar-container"></div>
  
	<header  id="tm-header2">
        <div class="tm-header-wrapper">
            <button class="navbar-toggler" type="button" aria-label="Toggle navigation">
                <i class="fas fa-bars"></i>
            </button>

            <nav class="tm-nav" id="tm-nav">            
                <ul>
                    <li class="tm-nav-item"><a href="index.html" class="tm-nav-link">
                        <i class="fas fa-home"></i>
                        
                    </a></li>
                    
                </ul>
            </nav>
           
            
        </div>
    </header>
    <div>
        <main class="tm-main">
                   
            
            <div class="row tm-row">
                <div class="col-lg-11 tm-post-col">
                    <div class="tm-post-full">                    
                        <div class="mb-4">
                            <h1 class="pt-2 tm-color-primary"> El Teorema de Fagin</h1>
            <hr>
            <p style="text-align: justify;" >            
            <h2 class="pt-2 tm-color-primary tm-post-title"> Una Caractizacion de NP en Segundo Orden </h2>
            <p class="tm-mb-40">Publicado por Luis G. | Fecha: 21 de Marzo, 2025</p>
            
            <p>
                La <strong>lógica de segundo orden con cuantificadores existenciales (\(\text{SO} \exists\))</strong> amplía la lógica de primer orden permitiendo cuantificar sobre relaciones, 
                lo que la hace extremadamente expresiva. En este contexto, el <strong>Teorema de Fagin</strong> establece que la clase <strong>NP</strong> es exactamente el conjunto de problemas 
                que pueden formularse mediante expresiones en <strong>\(\text{SO} \exists\)</strong>. Este resultado proporciona una caracterización <strong>máquina-independiente</strong> 
                de <strong>NP</strong> y fue el punto de partida del campo de la <strong>complejidad descriptiva</strong>, al demostrar que los problemas computacionales pueden 
                describirse en términos de lógica sin necesidad de hacer referencia a modelos de cómputo como las máquinas de Turing. Un corolario derivado de este resultado, propuesto por 
                <strong>Stockmeyer</strong>, afirma que las consultas expresadas en lógica de segundo orden corresponden exactamente a los problemas que se pueden resolver en la 
                <strong>jerarquía polinomial</strong>, lo que resalta la profundidad de esta conexión entre <strong>expresividad lógica</strong> y <strong>complejidad computacional</strong>.
            </p>
        
            <p>
                La potencia de <strong>\(\text{SO} \exists\)</strong> radica en su capacidad para describir de manera compacta y estructurada problemas que capturan la esencia de 
                <strong>NP-completitud</strong>, como <strong>SAT, CLIQUE y 3-COLORACIÓN</strong>, lo que nos permite entender <strong>NP</strong> desde una perspectiva lógica pura. 
                De hecho, <strong>Fagin</strong> demostró su teorema formulando una expresión lógica que describe las computaciones de una <strong>máquina de Turing no determinista</strong>, 
                cuantificando sobre las estructuras que representan los estados de la cinta y las transiciones de la máquina. Esta formulación confirma que 
                <strong>\(\text{SO} \exists \subseteq NP\)</strong> y a través de reducciones desde problemas <strong>NP-completos</strong> a fórmulas en 
                <strong>\(\text{SO} \exists\)</strong>, se establece la otra inclusión, <strong>demostrando la igualdad</strong>. En este post, exploraremos esta demostración en detalle, 
                siguiendo la estructura planteada por <strong>Fagin</strong> y comprendiendo cómo esta caracterización lógica se vincula con otros modelos de computación en la 
                <strong>jerarquía polinomial</strong>.
            </p>

            <h2 class="pt-2 tm-color-primary tm-post-title">¿Por qué una caracterización para NP?</h2>

            <p>
                
                Una caracterizacion de querys de segundo orden  nos proporciona una manera alternativa y más estructurada de entender NP: 
                mediante la <strong>lógica de segundo orden con cuantificadores existenciales (\(\text{SO} \exists\))</strong>. 
                Un ejemplo claro de esta caracterización lo encontramos en el <strong>problema del viajero (TSP)</strong>, cuya formulación lógica en <strong>\(\text{SO} \exists\)</strong> 
                nos permite ver cómo la expresividad de esta lógica capta la esencia de NP.
            </p>

            <p>
                En el problema <strong>TSP</strong>, recibimos como entrada un <strong>grafo no dirigido</strong> \( G \) con <strong>pesos en sus aristas</strong> y un <strong>límite \( L \)</strong>. 
                La consulta <strong>TSP</strong> es <strong>verdadera</strong> si existe un <strong>circuito hamiltoniano</strong> en \( G \) cuya <strong>suma total de pesos</strong> es como máximo \( L \). 
                Para modelar este problema en términos lógicos, se define un vocabulario \( \tau_{\text{TSP}} \), compuesto por:
            </p>

            <ul>
                <li>\( W(x, y, \cdot) \): Una cadena binaria que representa el <strong>peso</strong> de cada arista \( (x, y) \).</li>
                <li>\( L(\cdot) \): Una cadena binaria que representa el <strong>límite de peso permitido \( L \)</strong>.</li>
            </ul>

            <p>
                Para expresar esto en <strong>\(\text{SO} \exists\)</strong>, seguimos dos pasos fundamentales:
            </p>

            <h5>1. Asegurar la existencia de un circuito hamiltoniano</h5>
            <p>
                Se introduce una <strong>relación binaria</strong> \( H(x, y) \), donde \( H(x, y) \) indica que hay una arista en el circuito entre los vértices \( x \) y \( y \).
                Esta relación debe cumplir dos condiciones:
            </p>

            <ul>
                <li>Todo vértice tiene exactamente <strong>dos conexiones</strong> en \( H(x, y) \): una de entrada y otra de salida.</li>
                <li>Las aristas en \( H(x, y) \) deben ser <strong>aristas reales del grafo \( E(x, y) \)</strong>.</li>
            </ul>

            <p>Esto se expresa como:</p>
            <p class="text-center">
                \[
                (\exists H^2) \Big[ \forall x \exists y (H(x, y) \wedge H(y, x)) \wedge \forall x \forall y (H(x, y) \rightarrow E(x, y)) \Big]
                \]
            </p>

            <h5>2. Restringir la suma de los pesos</h5>
            <p>
                Para garantizar que la <strong>suma de los pesos no supere \( L \)</strong>, se introduce una <strong>relación ternaria</strong> \( R(x, y, s) \),
                donde \( s \) representa la <strong>suma acumulada</strong> de pesos hasta el vértice \( y \). Se impone la siguiente restricción:
            </p>

            <p class="text-center">
                \[
                (\exists R^3) \Big[ \forall x \forall y (H(x, y) \rightarrow R(x, y, s)) \wedge \forall x \forall y (R(x, y, s) \rightarrow (s \leq L)) \Big]
                \]
            </p>
            <p>
                Este análisis del <strong>problema del viajero (TSP)</strong> nos permite ver cómo la <strong>lógica de segundo orden con cuantificadores existenciales (\(\text{SO} \exists\))</strong> captura de manera natural la estructura de problemas en <strong>NP</strong>. A través de la formulación lógica, hemos logrado expresar tanto la existencia de un <strong>circuito hamiltoniano</strong> como la <strong>restricción sobre la suma de los pesos</strong>, sin necesidad de recurrir directamente a una máquina de Turing. Este enfoque demuestra el poder de \(\text{SO} \exists\) para caracterizar problemas computacionales complejos de manera compacta y estructurada. En las siguientes secciones, exploraremos cómo esta caracterización se extiende a otros problemas <strong>NP-completos</strong>, fortaleciendo la conexión entre <strong>lógica y complejidad computacional</strong> en la demostración del <strong>Teorema de Fagin</strong>.
            </p>
            

            <h2 class="pt-2 tm-color-primary tm-post-title">Demostración del Teorema de Fagin</h2>

            <p>
                La demostración de Fagin se basa en dos direcciones: 
            </p>
            
            <ul>
                <li><strong>(1) Toda consulta expresable en \(\text{SO} \exists\) pertenece a NP</strong>, lo que implica que cualquier problema que pueda describirse con una 
                    fórmula de segundo orden existencial también puede ser resuelto por una máquina de Turing no determinista en tiempo polinomial.</li>
                <li><strong>(2) Todo problema en NP puede expresarse en \(\text{SO} \exists\)</strong>, lo que significa que la estructura lógica de estos problemas 
                    puede capturarse completamente mediante cuantificación sobre relaciones.</li>
            </ul>
        
            <h4>Dirección fácil: \(\text{SO} \exists \subseteq NP\)</h4>
        
            <p>
                Para demostrar que cualquier consulta en \(\text{SO} \exists\) pertenece a NP, consideremos una fórmula de la forma:
            </p>
        
            <p class="text-center">
                \[
                \Phi \equiv (\exists R_1^{r_1}) (\exists R_2^{r_2}) \dots (\exists R_k^{r_k}) \psi
                \]
            </p>
        
            <p>
                donde \( \psi \) es una fórmula de primer orden y \( R_1, R_2, \dots, R_k \) son relaciones existencialmente cuantificadas. 
                Nuestro objetivo es construir una máquina de Turing no determinista \( N \) que, dado un input \( \mathcal{A} \), decida si \( \mathcal{A} \models \Phi \).
            </p>
        
            <p>
                La máquina \( N \) sigue el siguiente procedimiento:
            </p>
        
            <ol>
                <li>Escribe no determinísticamente una estructura extendida \( \mathcal{A}' = (\mathcal{A}, R_1, R_2, \dots, R_k) \), donde cada relación \( R_i \) es seleccionada arbitrariamente.</li>
                <li>Evalúa la fórmula de primer orden \( \psi \) sobre la estructura \( \mathcal{A}' \).</li>
                <li>Acepta si y solo si \( \mathcal{A}' \models \psi \).</li>
            </ol>
        
            <p>
                Dado que la evaluación de \( \psi \) se puede realizar en espacio logarítmico, y la generación no determinista de la estructura requiere solo un número polinomial de pasos, 
                concluimos que \( \Phi \) pertenece a NP. Esto prueba la dirección \(\text{SO} \exists \subseteq NP\).
            </p>
        
            <h4>Dirección difícil: \( NP \subseteq \text{SO} \exists \)</h4>
            
            <p>Sea <i>N</i> una <strong>máquina de Turing no determinista</strong> que opera en un tiempo máximo de <i>n<sup>k</sup> - 1</i> sobre una entrada codificada como bin(<i>A</i>), donde <i>n = |A|</i>. Para formalizar esta computación en términos de lógica de segundo orden, expresamos la existencia de una cómputo aceptante mediante la siguiente fórmula:</p>

            <p>
                \[
                \Phi \equiv (\exists C_1^{2k} \dots C_g^{2k} \Delta^k) \varphi
                \]
            </p>
            
            <p>Esta expresión establece que <strong>existe una codificación válida de un cómputo aceptante</strong> para <i>N</i>, en donde las relaciones <i>C</i> y <i>Δ</i> describen los estados de la máquina y su evolución a lo largo del tiempo. Más precisamente, la fórmula de primer orden <i>φ</i> verifica que para ciertos conjuntos <i>C</i> y <i>Δ</i>, la estructura ampliada <i>(A, C, Δ)</i> satisface la propiedad deseada, es decir, representa una ejecución válida de <i>N</i> sobre <i>A</i>. Esto nos permite establecer la equivalencia con la ecuación (7.7).</p>
            
            <p>Para describir formalmente la computación de <i>N</i>, introducimos una <strong>matriz</strong> <i>C(ś, t̄)</i> que modela la cinta de trabajo de la máquina. Cada celda de esta cinta puede almacenar información en un espacio de <i>n<sup>2k</sup></i> posiciones, variando en el tiempo desde <i>0</i> hasta <i>n<sup>k</sup> - 1</i>. Utilizamos <strong>tuplas de variables</strong> <i>t̄ = (t<sub>1</sub>, ..., t<sub>k</sub>)</i> y <i>ś = (s<sub>1</sub>, ..., s<sub>k</sub>)</i>, que recorren el universo de la estructura <i>A</i> en el rango de valores <i>0</i> a <i>n - 1</i>, permitiéndonos codificar las posiciones de la cinta en términos de lógica de primer orden.</p>
            
            <p>Cada <strong>par de valores</strong> <i>(ś, t̄)</i> dentro de <i>C(ś, t̄)</i> almacena el <strong>símbolo</strong> <i>σ</i> que aparece en la celda <i>ś</i> en el instante <i>t̄</i>, a menos que la cabeza de la máquina esté presente en esa celda. Si la cabeza de lectura se encuentra en la posición, entonces <i>C(ś, t̄)</i> codifica el <i>símbolo</i> <i>σ</i> y el<strong>estado actual</strong> de la máquina <i>N</i>, representado como un par <i>⟨q, σ⟩</i>, donde <i>q</i> denota el estado en el tiempo <i>t̄</i>.</p>
            
            <p>Para definir estos símbolos de manera formal, consideramos el conjunto:</p>
            
            <p>
                \[
                \Gamma = \{\gamma_0, \dots, \gamma_g\} = (Q \times \Sigma) \cup \Sigma
                \]
            </p>
            
            <p>donde <i>Q</i> es el conjunto de <strong>estados</strong> de la máquina y <i>Σ</i> es el <strong>alfabeto de la cinta</strong>. De esta manera, <i>Γ</i> agrupa todas las posibles configuraciones de contenido de una celda. Definimos además una <strong>relación de aridad 2k</strong>, denominada <i>C<sub>i</sub></i>, con <i>0 ≤ i ≤ g</i>, donde la interpretación intuitiva de <i>C<sub>i</sub>(ś, t̄)</i> es que la celda en la posición <i>ś</i> en el tiempo <i>t̄</i> contiene el símbolo <i>γ<sub>i</sub></i>.</p>
            
            <p>En cada paso, la <strong>máquina de Turing no determinista</strong> toma una de dos posibles decisiones. Estas elecciones están representadas mediante una relación <i>k</i>-aria, denotada como <i>Δ</i>. Intuitivamente, <i>Δ(t̄)</i> es verdadera si, en el paso <i>t̄ + 1</i> del cómputo, la máquina elige la opción "1"; en caso contrario, opta por la elección "0". Aunque estas decisiones pueden inferirse a partir de la estructura <i>C̄</i>, la formulación se simplifica al cuantificar explícitamente <i>Δ</i>. Para una mejor visualización del cómputo de <i>N</i>, remitimos a la Figura 7.9.</p>

<p>Con esta información, podemos expresar de manera clara la fórmula de primer orden <i>φ(C̄, Δ)</i>, que establece que <i>C̄</i> y <i>Δ</i> codifican una ejecución aceptante de <i>N</i>. La expresión <i>φ</i> se descompone en cuatro componentes fundamentales:</p>

<p>
    \[
    φ \equiv α \land β \land η \land ζ
    \]
</p>

<p>A continuación, se describen los significados de cada una de estas partes:</p>

<ul>
    <li><strong>α:</strong> Asegura que la primera fila del cómputo codifica correctamente la entrada <i>bin(A)</i>.</li>
    <li><strong>β:</strong> Garantiza que no ocurran solapamientos entre los símbolos almacenados en la cinta, es decir, no puede darse el caso en el que <i>C<sub>i</sub>(ś, t̄)</i> y <i>C<sub>j</sub>(ś, t̄)</i> sean simultáneamente verdaderas para <i>i ≠ j</i>.</li>
    <li><strong>η:</strong> Expresa que, para cada instante <i>t̄</i>, la fila <i>t̄ + 1</i> de <i>C̄</i> se obtiene de la fila <i>t̄</i> mediante la transición definida por <i>Δ(t̄)</i>.</li>
    <li><strong>ζ:</strong> Garantiza que la última fila del cómputo contiene el <strong>estado de aceptación</strong>.</li>
</ul>

<p>En particular, la condición <i>ζ</i> puede formularse explícitamente asumiendo que, cuando <i>N</i> alcanza un estado de aceptación, borra su cinta y se desplaza completamente hacia la izquierda hasta ingresar en un <strong>estado de aceptación único</strong>, que denotamos como <i>q<sub>f</sub></i>. Sea <i>γ<sub>17</sub></i> el elemento de <i>Γ</i> correspondiente al par <i>⟨q<sub>f</sub>, 1⟩</i>, donde <i>q<sub>f</sub></i> representa el estado de aceptación al observar el símbolo "1". De esta manera, establecemos:</p>

<p>
    \[
    ζ = C_{17}(0, max).
    \]
</p>

<p>Con estas condiciones formalizadas, hemos estructurado completamente la forma en que la lógica de segundo orden captura el cómputo aceptante de una máquina de Turing no determinista en el contexto del teorema de Fagin.</p>

<p>La oración η establece que el contenido de la celda de la cinta en la posición \((\bar{s}, \bar{t} + 1)\) se deriva de los contenidos de las celdas en \((\bar{s} - 1, \bar{t})\), \((\bar{s}, \bar{t})\) y \((\bar{s} + 1, \bar{t})\), de acuerdo con la transición \(\Delta(\bar{t})\) del autómata \(N\).</p>

<p>Se define una relación entre las configuraciones de los contenidos de las celdas, de tal forma que, si un conjunto específico de valores está presente en las posiciones indicadas, entonces la celda en la nueva posición adquirirá un valor determinado por la función de transición.</p>

<p>Formalmente, si un trío de valores \(\langle a_{-1}, a_0, a_1, \delta \rangle\) lleva a un valor \(b\) bajo la función de transición del sistema, se expresa como:</p>

<p>\[
\langle a_{-1}, a_0, a_1, \delta \rangle \xrightarrow{N} b
\]</p>

<p>Este enunciado sintetiza el hecho de que el nuevo valor de la celda en \((\bar{s}, \bar{t} + 1)\) es el resultado de la aplicación de la función de transición \(\Delta(\bar{t})\) sobre los valores previamente almacenados en las celdas adyacentes.</p>

<table>
    <tr>
        <th rowspan="2">Time</th>
        <th colspan="7">Space</th>
        <th rowspan="2">Δ</th>
    </tr>
    <tr>
        <th>0</th> <th>1</th> <th>p</th> <th>n - 1</th> <th>n</th> <th>...</th> <th>nk - 1</th>
    </tr>
    <tr>
        <td class="highlight">0</td>
        <td>&#x27E8;q₀, w₀&#x27E9;</td> <td>w₁</td> <td>...</td> <td>wₙ₋₁</td> <td>⊔</td> <td>...</td> <td>⊔</td>
        <td>δ₀</td>
    </tr>
    <tr>
        <td class="highlight">1</td>
        <td>w₀</td> <td>&#x27E8;q₁, w₁&#x27E9;</td> <td>...</td> <td>wₙ₋₁</td> <td>⊔</td> <td>...</td> <td>⊔</td>
        <td>δ₁</td>
    </tr>
    <tr>
        <td class="highlight">...</td>
        <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td>
        <td>...</td>
    </tr>
    <tr>
        <td class="highlight">t</td>
        <td>...</td> <td>...</td> <td class="boxed">a₋₁</td> <td class="boxed">a₀</td> <td class="boxed">a₁</td> <td>...</td> <td>...</td>
        <td>δₜ</td>
    </tr>
    <tr>
        <td class="highlight">t + 1</td>
        <td>...</td> <td>...</td> <td colspan="3" class="boxed">b</td> <td>...</td> <td>...</td>
        <td>δₜ₊₁</td>
    </tr>
    <tr>
        <td class="highlight">nk - 1</td>
        <td>&#x27E8;qf, 1&#x27E9;</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td>
        <td>...</td>
    </tr>
</table>

<p>An NP computation on input <em>w₀w₁...wₙ₋₁</em>; ⊔ denotes blank.</p>

<p>
    Para continuar con la demostración, definimos la expresión <strong>\(\eta_1\)</strong>, la cual formaliza la evolución de la computación a lo largo del tiempo. 
    En términos lógicos, esta expresión establece que para cualquier instante \( t \) que no sea el máximo y para cualquier posición \( \bar{s} \) dentro del rango permitido, 
    se debe cumplir una transición válida de estados. 
</p>

<p>
    Matemáticamente, esta restricción se expresa mediante la siguiente fórmula:
</p>

<p class="text-center">
    \[
    \eta_1 \equiv (\forall t . t \neq \text{max})(\forall \bar{s} . 0 < \bar{s} < \text{max}) 
    \bigwedge_{\langle a_{-1},a_0,a_1,\delta \rangle \overset{N}{\to} b} 
    
    \]
</p>
<p>
\[\left( \neg^\delta \Delta(t) \vee \neg C_{a_{-1}}(\bar{s} - 1, t) \vee \neg C_{a_0}(\bar{s}, t) 
\vee \neg C_{a_1}(\bar{s} + 1, t) \vee C_b(\bar{s}, t + 1) \right)\]
</p>

<p>
    En esta expresión, el operador \( \neg^\delta \) indica que si \( \delta \) toma el valor de 1, entonces la negación implica que se debe cumplir una transición determinada.
    Si \( \delta \) es 0, se interpreta como un símbolo vacío.
</p>

<p>
    Finalmente, definimos <strong>\(\eta\)</strong> como la conjunción de tres restricciones:
</p>

<p class="text-center">
    \[
    \eta \equiv \eta_0 \wedge \eta_1 \wedge \eta_2
    \]
</p>

<p>
    donde \( \eta_0 \) y \( \eta_2 \) imponen las mismas restricciones para los casos extremos, es decir, cuando \( \bar{s} \) toma los valores 0 o el máximo permitido en la cinta.
</p>

<h2 class="pt-2 tm-color-primary tm-post-title"><strong> Conclusión</strong></h2>

<p>Hemos construido una fórmula en <strong>\(\text{SO} \exists\)</strong> que describe la ejecución de cualquier máquina de Turing no determinista que opera en tiempo polinomial. Esto prueba que:</p>

<p>\[
NP \subseteq \text{SO} \exists
\]</p>

<p>Dado que ya demostramos que <strong>\(\text{SO} \exists \subseteq NP\)</strong>, concluimos que:</p>

<p>\[
NP = \text{SO} \exists
\]</p>

<p>Este resultado es fundamental porque nos proporciona una <strong>caracterización lógica de NP independiente de las máquinas de Turing</strong> y fundamenta el campo de la <strong>complejidad descriptiva</strong>.</p>






            
            <!-- Botones de navegación -->
            <div class="text-center mt-4">
                <a href="post 10 El gran paso.html" class="btn btn-primary mr-2">⟵ El gran paso hacia SO∃ = NP</a>
                <a href="post 13 Final del viaje.html" class="btn btn-primary"> Final del Viaje ⟶</a>
            </div>
            
            <footer class="row tm-row">
                <div class="col-md-6 col-12 tm-color-gray">
                    Unal
                </div>
                <div class="col-md-6 col-12 tm-color-gray tm-copyright">
                    Luis Gómez.
                </div>
            </footer>
        </main>
    </div>
    <script src="js/jquery.min.js"></script>
    <script>
        $("#sidebar-container").load("sidebar.html", function() {
  const currentUrl = window.location.href;
  console.log("Current URL:", currentUrl);
  
  $("#tm-nav a").each(function() {
    const linkUrl = $(this).prop("href");
    console.log("Comparando con:", linkUrl);
    if (currentUrl.indexOf(linkUrl) !== -1) {
      $(this).closest("li").addClass("active");
    } else {
      $(this).closest("li").removeClass("active");
    }
  });
});
      </script>
    <script src="js/templatemo-script.js"></script>
</body>
</html>