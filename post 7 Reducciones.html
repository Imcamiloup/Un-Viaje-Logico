<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Xtra Blog</title>
	<link rel="stylesheet" href="fontawesome/css/all.min.css"> <!-- https://fontawesome.com/ -->
	<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet"> <!-- https://fonts.google.com/ -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/templatemo-xtra-blog.css" rel="stylesheet">
<!--
    
TemplateMo 553 Xtra Blog

https://templatemo.com/tm-553-xtra-blog

-->
</head>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<body>
    <div id="sidebar-container"></div>
    <div>
        <main class="tm-main">
                   
            
            <div class="row tm-row">
                <div class="col-lg-11 tm-post-col">
                    <div class="tm-post-full">                    
                        <div class="mb-4">
                            <h1 class="pt-2 tm-color-primary">Reduccciones</h1>
                            <hr>
                            <h2 class="pt-2 tm-color-primary tm-post-title">Transformando Problemas: La Lógica de las Reducciones en la Clasificación Computacional </h2>
                            <p class="tm-mb-40">Publicado por Daniel Bocanegra | Fecha: 12 de Febrero, 2024</p>
                            
                           
              <!-- SECCIÓN 1: REDUCCIONES DE TURING -->
              <h3 class="tm-color-primary">1. Reducciones de Turing y Problemas Completos</h3>
              <p>
                Para comparar la complejidad de consultas booleanas, una de las metodologías más utilizadas es la
                <em>reducción de Turing</em>. La idea fundamental consiste en dotar a una máquina de Turing de un
                “<em>oráculo</em>” que responda en tiempo constante si una estructura determinada pertenece a un
                conjunto o satisface una propiedad previamente elegida. En la práctica, se modela esta idea
                mediante una <em>máquina de Turing con oráculo</em>.
              </p>
              <p>
                Cuando una máquina de Turing <em>M</em> posee un oráculo para un conjunto (o consulta) <em>B</em>,
                se denota por \(M^B\). Esta máquina puede, en cualquier momento de su ejecución, escribir una
                cadena \(w\) en una cinta especial y entrar en un “estado de consulta”. El oráculo responde de
                inmediato si \(w\) pertenece o no a <em>B</em>, escribiendo un “1” o un “0” en la cinta de consulta.
                Este mecanismo permite que <em>M^B</em> resuelva, en el tiempo que toma una sola transición,
                cualquier pregunta de pertenencia a <em>B</em>.
              </p>
              <p>
                Desde el punto de vista de la complejidad, el acceso al oráculo puede agilizar ciertos cálculos. 
                Así, si un problema <em>A</em> es “fácil de computar” siempre que se disponga de
                un oráculo para <em>B</em>, decimos que <em>A</em> se <em>reduce por Turing</em> a <em>B</em>. De
                forma más rigurosa, decimos que <em>A</em> es \(\,C\)-Turing-reducible a <em>B</em> si existe una
                máquina de Turing con oráculo para <em>B</em> que corre en la clase de complejidad <em>C</em> y
                decide (o computa) <em>A</em>. Se escribe, por ejemplo:
              </p>
              <p class="tm-mb-40">
                \[
                  A \;\le_{T}^C\; B,
                \]
              </p>
              <p>
                para indicar que <em>A</em> está contenido en la clase de problemas que pueden resolverse en
                <em>C</em> al disponer de un oráculo para <em>B</em>. Un caso particular muy estudiado es la
                <em>reducción de Turing en tiempo polinómico</em>, denotada \(\le_{T}^P\), donde la máquina
                opera en tiempo polinómico con acceso al oráculo.
              </p>
              <p>
                La motivación original de <em>Turing</em> para definir oráculos surge de la búsqueda de métodos
                que, incluso ante problemas no computables (como el famoso problema de la parada), pudieran
                responder a preguntas de pertenencia. En la teoría de la complejidad, los oráculos se utilizan
                para capturar conjuntos o consultas más “complicados” que, sin embargo, pueden acelerar ciertos
                algoritmos.
              </p>
              <p>
                Un ejemplo común de reducción de Turing consiste en un problema <em>A</em> que, para resolverse,
                efectúa múltiples llamadas a la consulta <em>B</em>. Si tales llamadas pueden enmarcarse en un
                modelo de cómputo con recursos limitados (tiempo o espacio), se concluye que <em>A</em> no es más
                difícil que <em>B</em> bajo ese modelo. Este razonamiento es la base para clasificar
                <em>problemas completos</em>: si <em>A</em> está en la clase <em>C</em> y cualquier otro problema
                de <em>C</em> se reduce por Turing a <em>A</em>, entonces decimos que <em>A</em> es
                <em>completo</em> para la clase <em>C</em>.
              </p>
              <p>
                La relevancia de estas reducciones radica en que nos permiten agrupar problemas con comportamientos
                “equivalentes” en términos de complejidad. Además, reflejan la idea de que, para resolver <em>A</em>,
                bastaría con un “subrutina perfecta” para <em>B</em>. En muchos casos, la búsqueda de
                <em>problemas completos</em> en distintas clases de complejidad ha contribuido a comprender mejor la
                estructura y los límites de la computación (por ejemplo, <em>NP-completitud</em> o
                <em>PSPACE-completitud</em>).
              </p>

              <h3 class="tm-color-primary">2. Ejemplo: MAX-CLIQUE</h3>
              <p>
                El problema de <em>MAX-CLIQUE</em> consiste en, dado un grafo \(G\) y un entero \(k\),
                determinar si existe un subconjunto de vértices de tamaño \(k\) en el que todos los pares
                de vértices estén conectados por una arista (a este subconjunto se le denomina <em>clique</em>).
                Dicho de otro modo, un <em>clique</em> es un subgrafo completo sobre \(k\) vértices dentro
                de \(G\).
              </p>
              <p>
                Para ilustrar cómo se aplica una <em>reducción de Turing</em> en este contexto, se asocia
                a cada par \(\bigl(G,\, i,\, a\bigr)\) la pregunta de si el \(i\)-ésimo bit de
                \(\mathrm{MAX-CLIQUE}(G)\) coincide con “\(a\)”. La idea es que, al disponer de un
                oráculo que responda preguntas relativas a la existencia de cliques de diversos tamaños
                (por ejemplo, si el grafo contiene un clique de tamaño \(m\)), una máquina de Turing
                puede consultar repetidamente dicho oráculo para “reconstruir” la solución bit a bit.
              </p>
              <p>
                Se demuestra así que <em>MAX-CLIQUE</em> puede resolverse en tiempo polinómico, siempre
                que exista acceso al oráculo para el problema <em>CLIQUE</em> (el cual evalúa de manera
                puntual la presencia de cliques específicos en el grafo). Esta construcción ilustra
                cómo, bajo una reducción de Turing, el problema <em>MAX-CLIQUE</em> entra en la clase
                <em>NP</em>-completa, remarcando la importancia que tienen los subproblemas (oráculos)
                para determinar la dificultad intrínseca de los problemas.
              </p>
              
              <h3 class="tm-color-primary">3. Reducción Varios a Uno</h3>
              <p>
                La <em>reducción varios a uno</em> consiste en una única transformación 
                que toma una instancia de un problema \(A\) y la convierte 
                en una instancia de otro problema \(B\). Formalmente, se define una consulta
              </p>
              <p class="tm-mb-40">
                \[
                  I : \mathrm{STRUC}[\sigma] \;\to\; \mathrm{STRUC}[\tau]
                \]
                tal que, para cada estructura \(\mathbf{X}\),
                \[
                  \mathbf{X} \in A \;\;\Longleftrightarrow\;\; I(\mathbf{X}) \in B.
                \]
              </p>
              <p>
                Si esta transformación \(I\) es expresable en primer orden (o pertenece 
                a cierta clase de complejidad), se dice que \(A\) se reduce 
                varios a uno a \(B\) en ese marco. El rasgo distintivo de esta 
                metodología es que, a diferencia de la <em>reducción de Turing</em>, 
                no se permiten múltiples consultas a un “oráculo”: en lugar de ello, 
                se hace una sola conversión de la entrada de \(A\) a la de \(B\). 
                Desde la perspectiva lógica, esto implica describir la construcción 
                de la instancia de \(B\) usando un número finito de fórmulas, 
                sin recursión ni llamadas sucesivas a subproblemas.
              </p>
              <p>
                Esta noción de reducción es fundamental para clasificar problemas 
                en términos de <em>completitud</em>. Si un problema \(A\) 
                puede “reducirse” a \(B\) mediante un único paso definible 
                en la lógica de primer orden, entonces la complejidad de \(A\) 
                no excede la de \(B\) dentro del lenguaje lógico o la clase 
                de complejidad elegida. A su vez, este enfoque posibilita 
                análisis más precisos de las propiedades de definibilidad: 
                al mostrar que una operación se describe mediante una reducción 
                varios a uno, queda claro cómo la expresividad requerida 
                se transfiere de \(A\) a \(B\).
              </p>

              <h3 class="tm-color-primary">4. Ejemplo de Reducción Varios a Uno: 3-SAT a VERTEX COVER</h3>
<p>
  Para ilustrar la mecánica de una <em>reducción varios a uno</em>, 
  consideremos un caso clásico que convierte una instancia de 
  <strong>3-SAT</strong> (la tarea de verificar la satisfacibilidad 
  de una fórmula CNF con cláusulas de longitud 3) en una instancia de 
  <strong>VERTEX COVER</strong> (averiguar si existe un conjunto 
  de vértices de tamaño \(k\) que cubra todas las aristas de un grafo).
</p>

<p>
  El método consiste en un solo paso que, a grandes rasgos, 
  “proyecta” la <em>estructura lógica</em> de la fórmula 3-SAT —sus variables 
  y cláusulas— sobre un <em>grafo</em> cuyos vértices representan 
  literales, y cuyas aristas reflejan conflictos o incompatibilidades. 
  Así, la posibilidad de cubrir las aristas del grafo con un número reducido 
  de vértices se corresponde, con la existencia 
  de una asignación booleana que satisfaga la fórmula original. 
  El esquema se detalla a continuación:
</p>

<ol>
  <li>
    <strong>Vértices para cada literal</strong>  
    <br/>
    Si la fórmula cuenta con variables \(x_1,\dots,x_n\) y cláusulas 
    \(C_1,\dots,C_m\), se crea un vértice para cada literal 
    (por ejemplo, \(x_i\) y \(\neg x_i\)). 
    Estas representaciones conforman la base de la 
    <em>“proyección” lógica</em> hacia un modelo puramente gráfico.
  </li>

  <li>
    <strong>Aristas de incompatibilidad</strong>  
    <br/>
    Se añade una arista para cada par de literales que no pueden ser 
    verdaderos simultáneamente, bien porque se contradicen (caso de 
    \(x_i\) y \(\neg x_i\)), o bien porque pertenecen a la misma cláusula 
    y no resulta factible interpretarlos juntos. Esto garantiza que 
    cubrir las aristas equivalga a “seleccionar” un literal por cláusula 
    sin caer en conflicto.
  </li>

  <li>
    <strong>Fijar la cota de vértices</strong>  
    <br/>
    Para asegurar que la cobertura de vértices sea un análogo de la 
    satisfacibilidad, se define \(k\) (el tamaño máximo de la cobertura) 
    de tal forma que \(\,k = \text{número de cláusulas}\). 
    Así, localizar un vertex cover de tamaño \(k\) equivale a escoger, 
    en cada cláusula, un literal que cubra los conflictos (aristas) 
    asociados.
  </li>
</ol>

<p>
  De este modo, <em>3-SAT</em> se representa en un grafo cuyo comportamiento 
  —a nivel de vértices y aristas— captura la lógica de satisfacibilidad: 
  cada <em>literal</em> deviene un posible vértice que puede “cubrir” 
  las aristas que expresarían incompatibilidades. Resolver 
  <strong>VERTEX COVER</strong> bajo esta construcción determina si 
  existe un conjunto de literales consistente que satisfaga la fórmula. 
  En términos de complejidad, la reducción se logra en tiempo polinómico, 
  y el resultado final revela que <strong>VERTEX COVER</strong> es tan complejo 
  como <em>3-SAT</em> al menos dentro de la misma clase de complejidad 
  (por ejemplo, NP).
</p>

<p>
  Con ello, vemos cómo un <em>sistema lógico</em> (la colección de cláusulas 
  3-SAT) se “proyecta” en la <em>estructura gráfica</em> de 
  <em>VERTEX COVER</em>: cada restricción lógica (no poder elegir ciertos 
  literales en conjunto) se refleja en aristas que no pueden ignorarse 
  en la cobertura. Esta correspondencia simple, pero potente, es 
  la esencia de las reducciones varios a uno y pone en relieve la 
  capacidad de la teoría de modelos finitos para traducir formalmente 
  una lógica de satisfacibilidad en un problema gráfico.
</p>
              

              <h3 class="tm-color-primary">5. Definición de Completitud</h3>
              <p>
                En el contexto de una clase de complejidad
                <em>C</em>, se dice que un problema
                <em>A</em> es <strong>completo</strong> para
                <em>C</em> si cumple dos condiciones:
              </p>
              
              <p class="tm-mb-40">
                1. \(A \in C\). Es decir, <em>A</em> puede resolverse
                empleando los recursos que definen a <em>C</em>.<br/><br/>
                2. Para todo problema \(B \in C\), se cumple
                \(B \,\le_r\, A\). En otras palabras, existe
                una reducción (ya sea varios a uno o de Turing)
                que transforma, de manera eficiente, cualquier
                instancia de \(B\) en una instancia de <em>A</em>.
              </p>
              
              <p>
                Bajo esta definición, <em>A</em> funge como el
                “caso más difícil” de la clase <em>C</em>, pues,
                si se puede resolver <em>A</em> bajo la reducción
                \(\le_r\), se puede igualmente resolver cualquier
                <em>B</em> de <em>C</em>. El tipo de reducción
                (por ejemplo, varios a uno en tiempo polinómico)
                determina la clase de completitud. Un ejemplo
                clásico es la <strong>NP</strong>-completitud,
                que exige reducciones varios a uno en tiempo
                polinómico: un problema completo para
                <strong>NP</strong> resulta tan difícil como
                cualquier otro problema de esa clase.
              </p>
              
              <p>
                Desde la perspectiva de la <em>lógica
                matemática</em>, esta noción se conecta con la
                idea de <em>definibilidad</em>: si la reducción
                que “traduce” instancias de <em>B</em> a
                instancias de <em>A</em> puede describirse con
                fórmulas en un lenguaje lógico (por ejemplo, la
                lógica de primer orden), entonces la complejidad
                de la operación queda atada a la expresividad de
                dicho lenguaje. Así, la definición de
                completitud hace hincapié en la
                perspectiva algorítmica y enfatiza la relación con la <em>teoría de
                modelos finitos</em> y la forma en que las
                propiedades lógicas delimitan nuestras
                capacidades de describir problemas dentro de
                cada clase de complejidad.
              </p>

              <h3 class="tm-color-primary">6. Ejemplos de Problemas Completos</h3>
<p>
  Las <em>clases de complejidad</em> suelen presentar uno o varios 
  problemas “emblemáticos”, que siguen la definición anterior de <strong>completitud</strong>, es decir, encapsulan la “dificultad máxima” de la clase. A continuación, 
  se listan algunos ejemplos por categoría:
</p>

<ul>
  <li>
    <strong>Para L</strong> (espacio logarítmico):  
    Determinar si un grafo no dirigido contiene un ciclo.  
    Estos problemas se resuelven con un uso muy reducido de memoria.
  </li>

  <li>
    <strong>Para NL</strong> (espacio logarítmico no determinista):  
    <em>REACH</em>, que pregunta si en un grafo dirigido existe un camino 
    de \(s\) a \(t\). También se incluye la versión no determinista 
    de <em>2-SAT</em>.
  </li>

  <li>
    <strong>Para P</strong> (tiempo polinómico determinista):  
    <em>CIRCUIT-VALUE-PROBLEM</em> (CVP), donde se evalúa la salida 
    de un circuito booleano acíclico, o <em>NETWORK-FLOW</em>, 
    para calcular el flujo máximo en un grafo con capacidades.
  </li>

  <li>
    <strong>Para NP</strong> (tiempo polinómico no determinista):  
    <em>3-SAT</em>, que decide la satisfacibilidad de fórmulas booleanas 
    en CNF con cláusulas de longitud 3, y <em>CLIQUE</em>, que verifica 
    si un grafo no dirigido posee un clique de tamaño \(k\).
  </li>

  <li>
    <strong>Para PSPACE</strong> (espacio polinómico determinista):  
    <em>QSAT</em>, el problema de la satisfacibilidad de fórmulas 
    cuantificadas, junto con versiones generalizadas de juegos 
    como <em>HEX</em>, <em>GEOGRAPHY</em> o <em>GO</em>.
  </li>
</ul>

<p>
  En cada caso, estos problemas funcionan como <em>puntos de referencia</em>: 
  si un problema se <em>reduce</em> (varios a uno o por Turing) 
  a uno de ellos bajo condiciones apropiadas, queda demostrado 
  que comparte la dificultad intrínseca de esa clase en particular. 
  Desde la perspectiva de la <em>lógica matemática</em>, ello implica 
  que describir la transformación hacia un problema completo 
  ofrece un método formal para situar, en términos lógicos y computacionales, 
  la complejidad de cualquier tarea en dicha clase.
</p>

<h3 class="tm-color-primary">7. Perspectiva desde la Lógica Matemática</h3>
<p>
  Cuando hablamos de <em>reducciones</em> y <em>problemas completos</em>, es fácil 
  quedarse en el plano meramente algorítmico, describiendo cómo una máquina transforma 
  la entrada de un problema <em>A</em> en la de otro problema <em>B</em>. Sin embargo, 
  desde el punto de vista de la <strong>lógica matemática</strong>, las reducciones 
  adquieren un matiz adicional: dejan de ser simples procedimientos y se convierten 
  en <em>descripciones formales</em> dentro de un lenguaje lógico.
</p>

<p>
  La <em>definibilidad</em> en lógicas como la de primer orden (FO), la de punto fijo 
  (FP) o la lógica existencial de segundo orden (ESO) ofrece una ventana 
  para entender la complejidad más allá del cómputo por sí mismo. En otras palabras, 
  si una reducción de <em>A</em> a <em>B</em> puede plasmarse como un conjunto de 
  fórmulas FO que describan en detalle cómo se obtiene la instancia de <em>B</em> 
  a partir de la de <em>A</em>, concluimos que la transformación no requiere una 
  “potencia lógica” superior a la de FO. Esto, a su vez, sitúa las clases de complejidad 
  —como \(\mathrm{P}\), \(\mathrm{NP}\) o \(\mathrm{PSPACE}\)— en un marco lógico en el 
  que las <em>consultas</em> y los <em>problemas</em> se vuelven propiedades o 
  definiciones “capturables” con tales fórmulas.
</p>

<p>
  Por ejemplo, cuando se demuestra que la operación de <em>multiplicación</em> de 
  enteros no puede describirse en lógica de primer orden sin extensiones, 
  se está diciendo que la <em>definibilidad</em> de tal operación sobre estructuras finitas 
  excede la expresividad de FO. De manera similar, si un método de reducción 
  “varios a uno” pudiera ser descrito mediante fórmulas FO, implicaría que la complejidad 
  y la <em>dificultad</em> de un problema se ajustan exactamente a 
  la capacidad de <em>describir</em> dicha reducción en el lenguaje en cuestión.
</p>

<p>
  Así, la relación entre <strong>lógica matemática</strong> y <strong>reducciones</strong> 
  es un diálogo: la forma en que modelamos la conversión 
  de un problema a otro afecta la clase lógica (o de complejidad) a la que pertenecen 
  dichas transformaciones. En la práctica, esta interacción se plasma en la 
  <em>complejidad descriptiva</em>, donde resultados tan profundos como la 
  caracterización de \(\mathrm{P}\) por la <em>lógica de punto fijo</em> 
  (Teoremas de Immerman-Vardi) y la caracterización de \(\mathrm{NP}\) por la 
  <em>lógica de segundo orden existencial</em> (Teorema de Fagin) muestran que 
  las reducciones, las clases de complejidad y la definibilidad lógica son 
  piezas de un mismo rompecabezas.
</p>

<p>
  Esta unión otorga rigor y elegancia a los conceptos de 
  “problema completo” y “reducción”, al situarlos en un entorno en el que 
  “describir” (en un lenguaje lógico) coincide con “computar” (en un modelo 
  algorítmico). Además revela limitaciones y potencialidades: hay propiedades 
  (como <em>paridad</em> de bits o ciertas operaciones aritméticas) que no son 
  expresables en lógicas simples, por tanto los problemas que las requieren 
  trascienden esas clases. En conjunto, la <strong>lógica</strong> se alza 
  como un instrumento decisivo para entender por qué ciertas reducciones 
  son factibles (y otras no) y cómo eso determina la clasificación 
  y la completitud de los problemas en la <em>teoría de la complejidad</em>.
</p>



          
                            <span class="d-block text-right tm-color-primary">Lógica . Computación . Matemáticas</span>
                        </div>                        
                    </div>
                </div>
            </div>
            
            
            <div class="row tm-row">
                <div class="col-md-6 col-12 tm-color-gray">
                    Unal
                </div>
                <div class="col-md-6 col-12 tm-color-gray tm-copyright">
                    Daniel Bocanegra .
                </div>
            </div>
            <!-- Botones de navegación -->
            <div class="text-center mt-4">
                <a href="post 6 Complejidad.html" class="btn btn-primary mr-2">⟵ Trasfondo en Complejidad</a>
                <a href="Post 8 Punto fijo.html" class="btn btn-primary"> Punto Fijo ⟶</a>
            </div>
            
            
            <footer class="row tm-row">
                <div class="col-md-6 col-12 tm-color-gray">
                  Bibliografía Esencial:
                </div>
                <div class="col-md-6 col-12 tm-color-gray tm-copyright">
                  <ul style="list-style-type: none; padding-left: 0;">
                    <li>Immerman, N. <em>Descriptive Complexity</em>. Springer, 1999.</li>
                    <li>Church, A. “An Unsolvable Problem of Elementary Number Theory.”, 1936.</li>
                    <li>Turing, A. M. “On Computable Numbers, with an Application to the Entscheidungsproblem.”, 1936.</li>
                    <li>Gödel, K. <em>On Undecidable Propositions of Formal Mathematical Systems</em>, 1931.</li>
                  </ul>
                </div>
              </footer>
        </main>
    </div>
    <script src="js/jquery.min.js"></script>
    <script>
        $("#sidebar-container").load("sidebar.html", function() {
  const currentUrl = window.location.href;
  console.log("Current URL:", currentUrl);
  
  $("#tm-nav a").each(function() {
    const linkUrl = $(this).prop("href");
    console.log("Comparando con:", linkUrl);
    if (currentUrl.indexOf(linkUrl) !== -1) {
      $(this).closest("li").addClass("active");
    } else {
      $(this).closest("li").removeClass("active");
    }
  });
});
      </script>
    <script src="js/templatemo-script.js"></script>
</body>
</html>